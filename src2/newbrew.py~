
    def __init__(self, pathin, pathout, state=0):
        pathin.__add_liquid_input__(self, pathout, state)
        pathout.__add_liquid_output__(self, pathin, state)

class LiquidBiPath(object):

    def __init__(self, path1, path2, state=0):
        self.path1 = LiquidPath(path1, path2, state)
        self.path2 = LiquidPath(path2, path1, state)

# Base Objects
class Component(object):

    def get_interface_components(self):
        return {}

    def get_components(self):
        return []

    def get_states(self):
        return {}


class LiquidComponent(Component):

    def __init__(self,
                 rate=float("inf"),
                 max_volume=0,
                 current_volume=0):
        self.max_volume = max_volume
        self.current_volume = current_volume
        self.rate = rate


    def get_rate(self, state):
        return self.rate

    def get_available_volume(self):
        return 0

class LiquidPort(LiquidComponent):

    def __init__(self, rate=float("inf")):
        self.rate = rate

    def get_rate(self, state):
        return self.rate

class LiquidVolume(LiquidPort):

    def __init__(self,
                 max_volume=float("inf"),
                 current_volume=0,
                 in_rate=float("inf"),
                 out_rate=float("inf")):
        self.max_volume
        self.current_volume = current_volume
        self.in_port = LiquidPort(in_rate)
        self.out_port = LiquidPort(out_rate)

    def get_interface_components(self):
        return { 

    def get_available_volume(self):
        return self.max_volume - self.current_volume



    def __init__(self, num_states=1, state=0, rate=float("inf")):
        self.state = state
        self.num_states = num_states
        self.liquid_inputs = [ set() for _ in range(num_states) ]
        self.liquid_outputs = [ set() for _ in range(num_states) ]
        self.rate = rate
        super(LiquidComponent, self).__init__()

    def __add_liquid_input__(self, component, state):
        self.liquid_inputs[state].add(component)

    def __add_liquid_output__(self, component, state):
        self.liquid_outputs[state].add(component)

    def get_available_flow_rate(self):
        rate_in = self.rate
        rates_out = [ output.get_available_flow_rate()
                    for output in self.liquid_outputs[self.state] ]
        num_rates_out = len(rates_out)
        total_rate_out = sum(rates_out)

        if total_rate_out > rate_in and num_rates_out > 1:
            warn("Cannot fulfill demand at a split")

        return min(total_rate_in, total_rate_out)

#    def supply(self, available):
#        available = min(available, self.rate)
#        remaining = available
#
#        for output in self.liquid_outputs[self.state]:
#            remaining -= output.supply(remaining)
#
#        return available - remaining

class LiquidConnector(LiquidComponent):
    pass

class LiquidPort(LiquidComponent):
    pass

class ManualLiquidPort(LiquidPort):
    pass

class LiquidVolume(LiquidComponent):
# Switch Everything to kwargs!
# You were in the middle of making receive and release
# They're meant to return how much they take, or how much they give
# If it involves a volume then the ratein/rateout/actualvolume must be taken into account
# Then loop through devices based on stae
# You need state to be stored at the part level somehow?
    def __init__(self,
                 volume,
                 input_rate=float("inf"),
                 output_rate=float("inf"),
                 initial_quantity=0,
                 overflow=false,
                 *args, **kwargs):
        self.volume = volume
        self.input_rate = input_rate
        self.output_rate = output_rate
        self.quantity = initial_quantity
        self.overflow = overflow
        super(LiquidVolume, self).__init__(*args, **kwargs)

    def get_available_volume(self):
        return self.volume - self.quantity

    def get_possible_flow_rate(self):
        if self.overflow:
            return self.input_rate

        # if we can't overflow then we can only put in as much as the pot can take, 
        # plus the amount that will be leaving too
        # unless the input_rate is lower

        available = self.volume - self.quantity
        for output in self.liquid_outputs:
            available += output.get_possible_flow_rate())

        return available

# Demand is the right word, supply is the wrong
# How about demand, consume and supply

# Supply is how much it supplies to the rest per timestep
# Maybe keep track of how much has supplied and
# consumed per timestep so can loop until stable?

# To convert to args and kwargs, introduce __component_init__(*args, *kwargs)
# Call it from Component.__init___
# Does this open up the requirement of __liquid_component_init__ etc?
# 
class Heater(Component):
    pass

class Thermometer(Component):
    pass

# Complex Objects
class Part(object):

    def __init__(self):
        self.ports = []
        self.volumes = []

class Kettle(Part):

    def __init__(self, volume):
        self.inputPort = LiquidPort()
        self.outputPort = LiquidPort()
        self.manualPort = ManualLiquidPort()
        self.ports = [ self.inputPort, self.outputPort, self.manualPort ]
        self.volumes = [ LiquidVolume(volume, true) ]

        LiquidBiPath(self.manualPort, self.volume)
        LiquidPath(self.inputPort, self.volume)
        LiquidPath(self.volume, self.outputPort)

        super(Kettle, self).__init__()

class BallValve2Way(Part):

    def __init__(self):
        self.states = 2
        self.ports = [ LiquidPort(states), LiquidPort(states) ]

        LiquidBiPath(self.ports[0], self.ports[1], 1)

        super(BallValve2Way, self).__init__()

class BallValve3Way(Part):

    def __init__(self):
        self.states = 2
        self.central_port = LiquidPort(self.states)
        self.switchable_ports = [ LiquidPort(self.states). LiquidPort(self.states) ]
        self.ports = [ self.central_port ] + self.switchable_ports

        LiquidBiPath(self.central_port, self.switchable_ports[0], 0)
        LiquidBiPath(self.central_port, self.switchable_ports[1], 1)

        super(BallValve3Way, self).__init__()

class Pump(Part):

    def __init__(self):
        self.states = 2
        self.input_port = LiquidPort(self.states)
        self.output_port = LiquidPort(self.states)
        self.ports = [ self.input_port, self.output_port ]

        LiquidPath(self.input_port, self.output_port, 1)

        super(Pump, self).__init__()

class HeatExchanger(Part):

    def __init__(self):
        self.heater = [ LiquidPort(), LiquidPort() ]
        self.heatee = [ LiquidPort(), LiquidPort() ]
        self.ports = self.heater + self.heatee

        LiquidBiPath(self.heater[0], self.heater[1])
        LiquidBiPath(self.heatee[0], self.heatee[1])

        super(HeatExchanger, self).__init__()

class WaterInput(Part):

    def __init__(self):
        self.output_port = LiquidPort(self.states)
        self.volume = Volume(float("inf"))
        self.ports = [ self.output_port ]
        self.volumes = [ self.volume ]

        LiquidPath(self.output_port, self.volumes[0])

        super(WaterInput, self).__init__()

class Drain(Part):

    def __init__(self):
        self.input_port = LiquidPort(self.states)
        self.ports = [ self.input_port ]

        super(Drain, self).__init__()

class Sparger(Part):

    def __init__(self):
        self.ports = [ LiquidPort(), LiquidPort() ]

        LiquidPath(self.ports[0], self.ports[1])
        LiquidPath(self.ports[1], self.ports[0])

        super(Sparger, self).__init__()

class Fermenter(Part):

    def __init__(self, volume):
        self.ports = [ LiquidPort() ]
        self.volume = Volume(volume, true)
        self.elements = [ self.volume ]

        LiquidPath(self.ports[0], self.volume)
